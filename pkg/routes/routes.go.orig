package routes

import (
	"net/http"
	"os"
	"fmt"
	"strings"
	"webapp/pkg/logger"
	"webapp/pkg/views"
)

const (
	reset    = "\033[0m"
	red      = "\033[31m"
	redbg    = "\033[41m"
	green    = "\033[32m"
	greenbg  = "\033[42m"
	orange   = "\033[38;5;208m"
	orangebg = "\033[48;5;208m"
	yellow   = "\033[33m"
	yellowbg = "\033[43m"
	blue     = "\033[34m"
	bluebg   = "\033[44m"
	cyan     = "\033[36m"
	cyanbg   = "\033[46m"
)

var methodColors = map[string]string{
	"GET":    bluebg,
	"POST":   cyanbg,
	"PUT":    yellowbg,
	"DELETE": redbg,
	"PATCH":  orangebg,
}

// CustomResponseWriter captures the status code and writes responses
type CustomResponseWriter struct {
	http.ResponseWriter
	StatusCode int
}

// WriteHeader captures the status code and writes the header
func (crw *CustomResponseWriter) WriteHeader(statusCode int) {
	if crw.StatusCode == 0 {
		crw.StatusCode = statusCode
	}
	crw.ResponseWriter.WriteHeader(statusCode)
}

// Write writes the response and ensures status code is set
func (crw *CustomResponseWriter) Write(b []byte) (int, error) {
	if crw.StatusCode == 0 {
		crw.StatusCode = http.StatusOK
	}
	return crw.ResponseWriter.Write(b)
}

// logOutput formats the log message with colors and status
func logFmt(status int, clientIp, method, url, pattern string) string {
	color, ok := methodColors[method]
	if !ok {
		color = reset
	}

return fmt.Sprintf(
	"%s %d %s| %s |%s %s %s| %s | %s", color, status, reset, clientIp, color, method, reset, url, pattern,
)
}

// staticFileMiddleware checks if the request is internal or external
func staticFileMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		crw := &CustomResponseWriter{ResponseWriter: w}

		if strings.HasPrefix(r.URL.Path, "/static/templates") {
			// Check if the request is internal
			if r.Header.Get("X-Internal-Request") == "true" {
				next.ServeHTTP(crw, r)
				logMsg := logFmt(crw.StatusCode, r.RemoteAddr, r.Method, r.URL.String(), "Static File")
				logger.Info.Print(logMsg)
				return
			}

			// Return forbidden for external requests
			http.Error(w, "403 Forbidden", http.StatusForbidden)
			logMsg := logFmt(http.StatusForbidden, r.RemoteAddr, r.Method, r.URL.String(), "403 Forbidden")
			logger.Info.Print(logMsg)
			return
		}

		// For non-static requests, proceed normally
		next.ServeHTTP(crw, r)
	})
}

// logMiddleware logs request details after the request is handled
func logMiddleware(mux *http.ServeMux) func(next http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			crw := &CustomResponseWriter{ResponseWriter: w}

			// Serve the HTTP request
			next.ServeHTTP(crw, r)

			if crw.StatusCode == 0 {
				crw.StatusCode = http.StatusOK
			}

			// Determine the route pattern
			_, pattern := mux.Handler(r)
			if pattern == "/" {
				pattern = "root" // Default if no pattern is found
			}

			// Log the request
			logMsg := logFmt(crw.StatusCode, r.RemoteAddr, r.Method, r.URL.String(), pattern)
			logger.Info.Print(logMsg)
		})
	}
}

// NotFoundHandler handles unhandled routes and returns a 404 error
func NotFoundHandler(w http.ResponseWriter, r *http.Request) {
	// Log the 404 error in the same format as the request logs
	logMsg := logFmt(http.StatusNotFound, r.RemoteAddr, "404 Not Found", r.URL.String(), "404 Not Found")
	logger.Error.Print(logMsg)
	http.Error(w, "404 Not Found", http.StatusNotFound)
}

// CustomFileSystem wraps the default file system to check for file existence
type CustomFileSystem struct {
	fs http.FileSystem
}

// Open checks if the file exists and returns it, or logs the error and returns an error
func (cfs CustomFileSystem) Open(name string) (http.File, error) {
	f, err := cfs.fs.Open(name)
	if err != nil {
		if os.IsNotExist(err) {
			logger.Error.Printf("File not found: %s", name)
		} else {
			logger.Error.Printf("Error opening file: %s, %v", name, err)
		}
		return nil, err
	}
	return f, nil
}

// CustomFileServer returns a file server handler that handles 404 errors and logs requests
func CustomFileServer(root http.FileSystem) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		crw := &CustomResponseWriter{ResponseWriter: w}
		_, err := root.Open(r.URL.Path)
		if os.IsNotExist(err) {
			NotFoundHandler(crw, r)
			return
		}
		http.FileServer(root).ServeHTTP(crw, r)
		if crw.StatusCode == 0 {
			crw.StatusCode = http.StatusOK
		}
		logMsg := logFmt(crw.StatusCode, r.RemoteAddr, "GET", r.URL.String(), "File Served")
		logger.Info.Print(logMsg)
	})
}

// RegisterRoutes sets up the routes and handlers for the application
func RegisterRoutes(mux *http.ServeMux) {
	// Serve static files with 404 handling and access control
	fs := CustomFileServer(CustomFileSystem{fs: http.Dir("../pkg/static")})
	mux.Handle("/static/", staticFileMiddleware(http.StripPrefix("/static/", fs)))
	logger.Debug.Printf("Loaded static web assets")

	// Handle root requests with middleware
	mux.Handle("/", logMiddleware(mux)(http.HandlerFunc(views.Index)))
}

// CustomServeMux is a custom mux that checks for matched routes and falls back to notFoundHandler
type CustomServeMux struct {
	mux             *http.ServeMux
	notFoundHandler http.Handler
}

// ServeHTTP checks for matched routes or falls back to notFoundHandler
func (csm *CustomServeMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	handler, pattern := csm.mux.Handler(r)
	if handler == nil || pattern == "" {
		csm.notFoundHandler.ServeHTTP(w, r)
	} else {
		handler.ServeHTTP(w, r)
	}
}

// NewCustomServeMux creates a new CustomServeMux with a notFoundHandler
func NewCustomServeMux(mux *http.ServeMux, notFoundHandler http.Handler) *CustomServeMux {
	return &CustomServeMux{
		mux:             mux,
		notFoundHandler: notFoundHandler,
	}
}

